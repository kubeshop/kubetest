package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.27

import (
	"context"
	"fmt"

	"github.com/kubeshop/testkube/internal/graphql/graph/model"
	"github.com/kubeshop/testkube/pkg/api/v1/testkube"
	executorsmapper "github.com/kubeshop/testkube/pkg/mapper/executors"
	"github.com/kubeshop/testkube/pkg/rand"
)

// Type is the resolver for the type field.
func (r *eventResolver) Type(ctx context.Context, obj *testkube.Event) (*string, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

// Resource is the resolver for the resource field.
func (r *eventResolver) Resource(ctx context.Context, obj *testkube.Event) (*string, error) {
	panic(fmt.Errorf("not implemented: Resource - resource"))
}

// Features is the resolver for the features field.
func (r *executorResolver) Features(ctx context.Context, obj *testkube.Executor) ([]*model.FeaturesListItem, error) {
	panic(fmt.Errorf("not implemented: Features - features"))
}

// Labels is the resolver for the labels field.
func (r *executorResolver) Labels(ctx context.Context, obj *testkube.Executor) (*string, error) {
	panic(fmt.Errorf("not implemented: Labels - labels"))
}

// Event is the resolver for the event field.
func (r *executorDetailsResolver) Event(ctx context.Context, obj *testkube.ExecutorDetails) (*testkube.Event, error) {
	panic(fmt.Errorf("not implemented: Event - event"))
}

// Tooltips is the resolver for the tooltips field.
func (r *executorMetaResolver) Tooltips(ctx context.Context, obj *testkube.ExecutorMeta) (*string, error) {
	panic(fmt.Errorf("not implemented: Tooltips - tooltips"))
}

// Executors is the resolver for the executors field.
func (r *queryResolver) Executors(ctx context.Context) ([]*testkube.Executor, error) {
	panic(fmt.Errorf("not implemented: Executors - executors"))
}

// Executors is the resolver for the executors field.
func (r *subscriptionResolver) Executors(ctx context.Context) (<-chan []testkube.ExecutorDetails, error) {
	ch := make(chan []testkube.ExecutorDetails)

	// TODO You can (and probably should) handle your channels in a central place outside of `schema.resolvers.go`.
	// For this example we'll simply use a Goroutine with a simple loop.
	go func() {
		r.Log.Infof("%+v\n", "subscribed to events.executor.>")

		queue := rand.String(30)

		err := r.Bus.SubscribeTopic("events.executor.>", queue, func(e testkube.Event) error {
			r.Log.Infof("%s %s %s\n", e.Type_, *e.Resource, e.ResourceId)

			execs, err := r.Client.List("")
			if err != nil {
				return err
			}

			executors := []testkube.ExecutorDetails{}
			for _, item := range execs.Items {
				executors = append(executors, executorsmapper.MapExecutorCRDToExecutorDetails(item))
			}

			ch <- executors
			return nil
		})

		if err != nil {
			go func() {
				<-ctx.Done()
				_ = r.Bus.Unsubscribe(queue)
			}()
		}
	}()

	return ch, nil
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Executor returns ExecutorResolver implementation.
func (r *Resolver) Executor() ExecutorResolver { return &executorResolver{r} }

// ExecutorDetails returns ExecutorDetailsResolver implementation.
func (r *Resolver) ExecutorDetails() ExecutorDetailsResolver { return &executorDetailsResolver{r} }

// ExecutorMeta returns ExecutorMetaResolver implementation.
func (r *Resolver) ExecutorMeta() ExecutorMetaResolver { return &executorMetaResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type eventResolver struct{ *Resolver }
type executorResolver struct{ *Resolver }
type executorDetailsResolver struct{ *Resolver }
type executorMetaResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func SliceToSliceOfPointers[T interface{}](in []T) (out []*T) {
	for _, e := range in {
		out = append(out, &e)
	}
	return
}
